- Memory Hierarchy: computers have a few megabytes of very fast, expensive, volatile cache memory, and a few terabytes of slow, cheap, nonvolatile magnetic or solid-state disck storage. 
- Memory Manager: keeps track of which parts of memory are in use, allocate memory to processes when they need it, and deallocate it when they are done. 
	No Memory Abstraction: 
		- Not possible to have two running programs in memory at the same time
		- Every program simply see's physical memory
		- Three ways of organizing physical memory only: 
			1) OS may be at bottom in RAM
			2) OS in ROM at the top
			3) the device drivers may be at the tope of memory in a ROM and the rest of the system in RAM 
		Running Multiple Programs Without a Memory Abstration: 
			- PSW (program status word) is a 4-bit key which allows protection to memory access
			- Static Relocation: when a program is loaded at an address, the constant address value is added to every program 
			address during the load process, which works, but requires extra information in all executable 
			programs to indicate which words contain relocatable addresses and which do not. 
	A Memory Abstration - Address Spaces:
		- Draw backs to exposing physical memory: 
			1) user programs can address every byte of memory, they can easily trash the operating system
			2) it is difficult to have multiple programs running at once
		- The Notion of an Address Space: 
			- Address Space: is the set of addresses that a process can use to address memory
				- Do not have to be numeric can be a set, like internet domains .com
		- Base and Limit Registers: 
			- Dynamic Relocation: maps each process' address space onto a different part of physical memory by using two special
			hardware registers, called base and limit
				- Base Register: When a program is run the base registers is loaded with the length of the program
					- every time a process references memory, either to fetch an instruction or read or write a data word, the
					CPU automatically adds the base value to the address generated by the process before sending the 
					address out on the memory bus
				- Limit register: checks wheher the address offered is equal to or greater than the value in the register, 
				in which case a fault is generated the access is aborted
				- Disadvantage: reloaction using base and limit registerse is the need to perform an addition and a 
				comparison on every memory reference
	Swapping: 
		- Swapping: consists of bringing in each process in its entirety, running it for awhile, 
		so they do not take up any memory when they are not running
		- Virtual Memory: Allows programs to run even when they are only partially in main memory
		- Memory compaction: when swapping creates multiple holes in memory, 
		it is possible to comibne them all into one big one by moving all the processes downward
		- most processes will grow as they run, so it is in our best interest to allocate a little extra memory
		whenever a process is swapped in or moved
			- when this is done we should only move the used memory to the disk and not include the additional space
		- We can give the processes and their components certain space and room, as well as directions, to grow
			- The stack can be at the top that grows downward, data segment shares the same space and grows upward
			- if they run into anothers space the process will need to swap to somewhere with more space or be killed 
	Managing Free Memory: 
		Memory Management with Bitmaps: 
			- Memory is divided into allocation units as small as a few words and as large as several kilobytes
			- Each allocation unit is a bit in the bitmap, which is 0 if the unit is free and 1 if it is occupied
	____  ___  _______   ____   __   _____   ___ ____ 
           |    A ||    ||       B    ||   C  ||   ||   D     || E ||     | processes in memory, empty block is free
	11111 00    111111     1111  00  111111  111  000   bit mapping
	|P|0|5|-|->|H|5|3|-|->|P|8|6|-|->|P|14|4|-|->|H|18|2|-|->|P|20|6|-|->|P|26|3|-|->|H|29|3|x| P - Process, H - hole	
		- Smaller the allocation unit, the larger the bitmap
		- Searching a bitmap for a run of a given length is slow
		Memory Management with Linked Lists: 
			- Linked lists can be leveraged to maintain memory
			- segment list is kept sorted by address, this makes updating the list straightforward and much easier
			- Doubly Linked lists may be better for this implementation
	Before X terminates				After X terminates
		|   A   |   X   |   B   |	becomes	|   A   |       |   B   |
		|   A   |   X   |         |    becomes	|   A   |                 |
		|        |   X   |   B   |     becomes	|	       |   B   |
		|        |   X   |         |    becomes	|		     |
		- List sorted allocation algorithms: 
			-First Fit Algorithm: Memory manager scans along the list of segments until it finds a hole that is big enough, 
			the hole is broen up into two pieces, one for the process and the other for the unused memory
				- fast algorithm
			- Next Fit Algorithm: similar to first fit except that it keeps track of where it is whenever it finds a suitable hole
			next time a hole is needed, it starts searching from the place where it left
			- Best Fit Algorithm: Searches the entire list, from beginning to end, and takes the smallest hole that is adequate, 
			attempting to find the best slot for the given size
				- slow and usually wastes more memory
			- Worst Fit Algorithm: Always take the largest available hole, so that the new hole will be big enough to be useful
			- Quick Fit Algorithm: maintains separate lists for some of the more common sizes requested
				- extremely fast, however determining if you can merge with your neighbor is expensive
	Virtual Memory: 
		- a solution for bloatware that was first discovered was creating overlays, which split programs into little pieces
		- Virtual memory: each program has its own address space, which is broken up into chunks called pages 
			- each page is a contiguous range of addresses 
			- pages are mapped onto physical memory but not all pages have to be in 
			  physical memory at the same time to run the program 
			- when the program references a part of its address space that is in physical memory, 
			  the hardware performs the necessary mappying
				- if not in physical memory, the OS is alerted to get the missing piece and re-execte the instruction that failed
		Paging: 
			-  Virtual addresses: program-generated addresses
			- Virtual addresses do not go directly to the memory bus, they go to the MMU Memory Management Unit, which maps 
			virtual addresses onto the physical memory addresses
			- virtual address space consists of fixed size units and the corresponding units in physical memory are page frames
			- Present/absent bit: keeps track of which pages are phyiscally present in memory
			- Page fault: when the MMU does not detect a mapped page, the CPU traps into the Operating System
				- operating system picks a little-used page frame and writes its contents back to the disk
				 (WHAT IS MEANT BY LITTLE USED PAGE FRAME?) 
				- fetrches from the disk the page that was just referenced into the page from just freed
				- changes the map
				- restarts the trapped instruction
			(NEED THIS PROCESS EXPLAINED) 
			- Page table: page numbers are used to index into, which yields the number of the page frame corresponding to
			 that virtual page 